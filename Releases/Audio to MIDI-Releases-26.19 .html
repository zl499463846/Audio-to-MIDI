<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>éŸ³é¢‘ è½¬ MIDI / Audio to MIDI</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0b0f1a;
            color: #e0e0e0;
            font-family: 'Segoe UI', system-ui;
            padding: 20px;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
        }

        h1 {
            color: #ffb347;
            font-size: 2.5rem;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #a0c0ff;
            margin-bottom: 30px;
            padding-left: 20px;
            border-left: 4px solid #ffb347;
        }

        .upload-area {
            background: #1e2437;
            border: 3px dashed #4f6f8f;
            border-radius: 30px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: 0.2s;
            margin-bottom: 20px;
        }

        .upload-area:hover {
            border-color: #ffb347;
            background: #252e45;
        }

        #fileName {
            margin-top: 15px;
            color: #ffb347;
            font-weight: bold;
        }

        .flex-row {
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .control-item {
            flex: 1 1 200px;
        }

        .control-item label {
            display: block;
            color: #ffb347;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .control-item input[type=range] {
            width: 100%;
        }

        .value-display {
            background: #0f1422;
            padding: 5px 10px;
            border-radius: 8px;
            text-align: center;
            margin-top: 5px;
        }

        .checkbox-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 15px 0;
        }

        .checkbox-item input {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }

        button {
            padding: 20px 45%;
            font-size: 1.1rem;
            border: none;
            border-radius: 40px;
            cursor: pointer;
            font-weight: bold;
            background: #4a9eff;
            color: white;
            margin: 5px;
            transition: 0.1s;
        }

        button.success {
            background: #5fb85f;
        }

        button:active {
            transform: translateY(2px);
            opacity: 0.9;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .progress-bar {
            background: #1e2437;
            height: 20px;
            border-radius: 10px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #4a9eff, #ffb347);
            transition: width 0.2s;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            margin: 20px 0;
        }

        .stat-card {
            background: #1e2437;
            border-radius: 12px;
            padding: 15px;
            text-align: center;
        }

        .stat-number {
            font-size: 2rem;
            font-weight: bold;
            color: #ffb347;
        }

        .warning {
            background: #332211;
            color: #ffcc99;
            padding: 15px;
            border-radius: 15px;
            margin: 20px 0;
        }

        .note-list {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            background: #1e2437;
            border-radius: 10px;
            padding: 10px;
            margin-top: 10px;
        }

        .note-tag {
            background: #0f1422;
            padding: 5px 10px;
            border-radius: 15px;
            font-size: 0.9rem;
            border-left: 3px solid #ffb347;
        }
    </style>
</head>
<body>
<div class="container">
    <h1>éŸ³é¢‘ è½¬ MIDI</h1>
    <div class="subtitle">ZLSR(zl499463846) 2026 å…¬ç›Šå¼€æºé¡¹ç›®ï¼Œéšæ„å•†ç”¨ï¼Œä¹Ÿå¯ä»¥è¯´æ—¶è‡ªå·±åšçš„ï¼Œæ¯•ç«Ÿè¿™ä¸ªé¡¹ç›®æŒºå®ç”¨çš„ï¼Œæ¬¢è¿ä¼ æ’­ï¼</div>

    <!-- ä¸Šä¼ åŒºåŸŸ -->
    <div class="upload-area" id="dropZone">
        <div style="font-size: 48px;">ğŸ“‚</div>
        <h3>ç‚¹å‡»æˆ–æ‹–æ”¾éŸ³é¢‘æ–‡ä»¶</h3>
        <input type="file" id="fileInput" accept="audio/*" style="display: none;">
        <div id="fileName"></div>
    </div>

    <!-- å‚æ•°æ§åˆ¶ -->
    <div class="panel">
        <div class="flex-row">
            <div class="control-item">
                <label>æœ€ä½MIDIéŸ³ç¬¦</label>
                <input type="range" id="minNote" min="0" max="126" value="0" step="1">
                <div class="value-display" id="minNoteVal">0</div>
            </div>
            <div class="control-item">
                <label>æœ€é«˜MIDIéŸ³ç¬¦</label>
                <input type="range" id="maxNote" min="1" max="127" value="127" step="1">
                <div class="value-display" id="maxNoteVal">127</div>
            </div>
            <div class="control-item">
                <label>FFTé‡å å› å­</label>
                <select id="fftOverlap"
                        style="width:100%; padding:20px; background:#0f1422; color:white; border:1px solid #4a5a7a; border-radius:8px; font-size:16px;">
                    <option value="2">2x (å¿«é€Ÿ)</option>
                    <option value="4" selected>4x (æ¨è)</option>
                    <option value="8">8x (å¹³æ»‘)</option>
                    <option value="16">16x (æé«˜æ—¶é—´åˆ†è¾¨ç‡)</option>
                </select>
            </div>
            <div class="control-item">
                <label>å“åº¦é˜ˆå€¼</label>
                <input type="range" id="threshold" min="0.001" max="0.1" step="0.001" value="0.005">
                <div class="value-display" id="thresholdVal">0.005</div>
            </div>
            <div class="control-item">
                <label>å“åº¦ç¼©æ”¾ (0.5-2.0)</label>
                <input type="range" id="loudnessScale" min="0.5" max="2.0" step="0.1" value="1.0">
                <div class="value-display" id="loudnessScaleVal">1.0</div>
            </div>
            <div class="control-item">
                <label>FFTå¤§å°</label>
                <select id="fftSize"
                        style="width:100%; padding:20px; background:#0f1422; color:white; border:1px solid #4a5a7a; border-radius:8px; font-size:16px;">
                    <option value="512">512 (é¢‘ç‡ç²¾åº¦æœ€ä½,æ—¶é—´ç²¾åº¦æœ€é«˜,ä½“ç§¯æœ€å¤§)</option>
                    <option value="1024">1024 (é¢‘ç‡ç²¾åº¦è¾ƒä½,æ—¶é—´ç²¾åº¦è¾ƒé«˜,ä½“ç§¯è¾ƒå¤§)</option>
                    <option value="2048">2048 (æ—¶é—´ç²¾åº¦ > é¢‘ç‡ç²¾åº¦,ä½“ç§¯å¤§ä¸€ç‚¹)</option>
                    <option value="4096" selected>4096 (å…¨é¢å¹³è¡¡,ä½“ç§¯é€‚ä¸­)</option>
                    <option value="8192">8192 (é¢‘ç‡ç²¾åº¦ > æ—¶é—´ç²¾åº¦,ä½“ç§¯å°ä¸€ç‚¹)</option>
                    <option value="16384">16384 (é¢‘ç‡ç²¾åº¦è¾ƒé«˜,æ—¶é—´ç²¾åº¦è¾ƒä½,ä½“ç§¯è¾ƒå°)</option>
                    <option value="32768">32768 (é¢‘ç‡ç²¾åº¦æœ€é«˜,æ—¶é—´ç²¾åº¦æœ€ä½,ä½“ç§¯æœ€å°)</option>
                </select>
            </div>
        </div>
        <div class="checkbox-item">
            <input type="checkbox" id="removeEmpty">
            <label for="removeEmpty">[å¯å‹¾é€‰]è‡ªåŠ¨å»é™¤ç©ºç™½å¸§ (ä¸æ¨è,å®¹æ˜“è¯¯ä¼¤æ­£å¸¸éŸ³ç¬¦)</label>
        </div>
        <p style="color: #a0c0ff; font-size: 0.9rem;">1. FFTé‡å å› å­ï¼šè¶Šå¤§éŸ³è´¨è¶Šé«˜ï¼Œå¤„ç†æ—¶é—´ä¼šæ›´é•¿</p>
        <p style="color: #a0c0ff; font-size: 0.9rem;">2. å“åº¦é˜ˆå€¼ï¼šé˜ˆå€¼è¶Šå°ï¼Œç”Ÿæˆçš„MIDIä½“ç§¯è¶Šå¤§ï¼ŒéŸ³è´¨è¶Šé«˜</p>
        <p style="color: #a0c0ff; font-size: 0.9rem;">3. å“åº¦ç¼©æ”¾ï¼šå½±å“ä¸å¤§ï¼Œé»˜è®¤å°±å¥½</p>
        <p style="color: #a0c0ff; font-size: 0.9rem;">4. FFTå¤§å°ï¼šFFTè¶Šå°ï¼Œç”Ÿæˆçš„MIDIä½“ç§¯è¶Šå¤§ï¼Œä¸º4096æ—¶éŸ³è´¨æœ€é«˜</p>
        <p style="color: #a0c0ff; font-size: 0.9rem;">5. è‡ªåŠ¨å»é™¤ç©ºç™½å¸§å¼€å¯åï¼Œæ²¡æœ‰ä»»ä½•éŸ³ç¬¦çš„å¸§å°†è¢«åˆ é™¤ï¼Œå‰©ä½™å¸§çš„æ—¶é—´è½´é‡æ–°è®¡ç®—ï¼Œæ€»æ—¶é•¿ç­‰äºåŸéŸ³é¢‘ï¼Œæ¶ˆé™¤é™éŸ³åœé¡¿</p>
        <p style="color: #ee8855; font-size: 0.9rem;">6. è¯·ä¸è¦åœ¨å¤„ç†æ—¶å¤šæ¬¡ç‚¹å‡»è½¬æ¢æŒ‰é’®ï¼Œå¦åˆ™å¯èƒ½é—ªé€€</p>
        <p style="color: #ee8855; font-size: 0.9rem;">7. è‹¥é¡µé¢å¡é¡¿æˆ–æ— å“åº”ï¼Œè¯·å…ˆä¸è¦å…³é—­ï¼Œè€å¿ƒç­‰å¾…ï¼ŒFFTç®—æ³•å¾ˆåƒCPUï¼Œæ…¢å·¥å‡ºç»†æ´»å˜›</p>
    </div>

    <!-- æ¨¡å¼é€‰æ‹©å’Œåˆ†æè¿›åº¦ -->
    <div class="panel">
        <div class="flex-row" style="justify-content: center;">
            <button id="dynamicBtn" class="success" disabled style="width:100%; margin:20px 0;">å¼€å§‹è½¬æ¢</button>
        </div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="progressText" style="text-align:center; margin-top:10px;">ç­‰å¾…ä¸Šä¼ æ–‡ä»¶...</div>
    </div>

    <!-- ç»Ÿè®¡ä¿¡æ¯ -->
    <div class="stats">
        <div class="stat-card">
            <div class="stat-number" id="statFrames">0</div>
            <div class="stat-label">åŸå§‹å¸§æ•°</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="statBins">0</div>
            <div class="stat-label">é¢‘ç‡é€šé“</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="statAvgNotes">0</div>
            <div class="stat-label">å¹³å‡éŸ³ç¬¦/å¸§</div>
        </div>
        <div class="stat-card">
            <div class="stat-number" id="statTotalNotes">0</div>
            <div class="stat-label">æ€»éŸ³ç¬¦æ•°</div>
        </div>
    </div>
    <div class="control-item">
        <label style="font-size:30px; text-align: center;">MIDIå¤„ç†æ¨¡å¼ï¼ˆè°ƒæ•´æ­¤é¡¹ä¸éœ€è¦é‡æ–°è½¬æ¢ï¼‰</label>
        <select id="midiMode"
                style="width:100%; padding:20px; background:#0f1422; color:white; border:1px solid #4a5a7a; border-radius:8px; font-size:16px; text-align: center;">
            <option value="normal" selected>é«˜éŸ³è´¨ç®—æ³•ï¼ˆå¯¹æ’­æ”¾å™¨è¦æ±‚æé«˜ï¼Œæ–‡ä»¶å¤§ï¼Œæ’­æ”¾å™¨å¾—å½“çš„è¯éŸ³è´¨æœ€é«˜ï¼‰</option>
            <option value="overlap">å¹³è¡¡ä¿®å¤ç®—æ³•ï¼ˆç‰ºç‰²å°éƒ¨åˆ†éŸ³è´¨ï¼Œæ–‡ä»¶å¤§ï¼Œå…¼å®¹æ€§ä¸€èˆ¬ï¼ŒéŸ³è´¨ç•¥å·®äºé«˜éŸ³è´¨ç®—æ³•ï¼‰</option>
            <option value="traditional">ä¼ ç»Ÿå¤„ç†ç®—æ³•(æ™®é€šçš„Audio to Midiç½‘ç«™çš„è½¬æ¢ç­–ç•¥ï¼Œæ–‡ä»¶å°ï¼Œé€šç”¨æ€§é«˜)</option>
        </select>
    </div>
    <!-- é¢„è§ˆæ’­æ”¾å™¨ -->
    <div id="previewPlayer" style="background: #1e2437; border-radius: 20px; padding: 20px; margin: 20px 0; display: none;">
        <div style="display: flex; align-items: center; gap: 15px; flex-wrap: wrap;">
            <button id="previewPlayBtn"
                    style="background: #5fb85f; color: white; border: none; border-radius: 30px; padding: 12px 25px; font-size: 1.1rem; cursor: pointer; font-weight: bold; transition: 0.1s;">
                â–¶ï¸ é¢„è§ˆMIDI
            </button>
            <button id="previewStopBtn"
                    style="background: #ff8c5a; color: white; border: none; border-radius: 30px; padding: 12px 25px; font-size: 1.1rem; cursor: pointer; font-weight: bold;">
                ğŸ—˜ åˆ·æ–°
            </button>
            <div style="flex: 1; min-width: 200px;">
                <input type="range" id="previewProgress" min="0" max="1000" value="0" style="width: 100%;">
                <div style="display: flex; justify-content: space-between; margin-top: 5px;">
                    <span id="previewCurrentTime">0:00</span>
                    <span id="previewTotalTime">0:00</span>
                </div>
            </div>
        </div>
    </div>
    <!-- ä¸‹è½½æŒ‰é’® -->
    <button id="downloadBtn" disabled style="width:100%; margin:20px 0;">ä¿å­˜(.mid)</button>

    <!-- é¢„è§ˆ -->
    <div class="panel">
        <h4 style="color:#ffb347;">æå–çš„éŸ³ç¬¦é¢„è§ˆ</h4>
        <div class="note-list" id="noteList">æš‚æ— éŸ³ç¬¦</div>
    </div>

    <div class="warning" id="info">è¯·ä¸Šä¼ éŸ³é¢‘æ–‡ä»¶!</div>
</div>
<p style="color: #aaaaee;text-align: center;"> æœ‰BUGä¸è¦æ¥éª‚æˆ‘ï¼Œè¿™ä¸ªç¨‹åºæ˜¯æˆ‘é—²ç€æ²¡äº‹åšçå†™çš„ï¼Œè§è°…...</p>
<script>
    (function () {
        // DOM å…ƒç´ 
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileNameDiv = document.getElementById('fileName');
        const dynamicBtn = document.getElementById('dynamicBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const infoDiv = document.getElementById('info');
        const noteListDiv = document.getElementById('noteList');
        const removeEmptyCheckbox = document.getElementById('removeEmpty');

        const minNoteSlider = document.getElementById('minNote');
        const maxNoteSlider = document.getElementById('maxNote');
        const minNoteVal = document.getElementById('minNoteVal');
        const maxNoteVal = document.getElementById('maxNoteVal');
        const thresholdSlider = document.getElementById('threshold');
        const thresholdVal = document.getElementById('thresholdVal');
        const fftSizeSelect = document.getElementById('fftSize');

        const statFrames = document.getElementById('statFrames');
        const statBins = document.getElementById('statBins');
        const statAvgNotes = document.getElementById('statAvgNotes');
        const statTotalNotes = document.getElementById('statTotalNotes');

        const loudnessScale = document.getElementById('loudnessScale');
        const loudnessScaleVal = document.getElementById('loudnessScaleVal');
        const fftOverlap = document.getElementById('fftOverlap');
        const midiModeSelect = document.getElementById('midiMode');

        // æ›´æ–°æ˜¾ç¤º
        loudnessScale.addEventListener('input', () => {
            loudnessScaleVal.innerText = parseFloat(loudnessScale.value).toFixed(1);
        });
        // åˆå§‹åŒ–æ˜¾ç¤º
        loudnessScaleVal.innerText = loudnessScale.value;
        dynamicBtn.innerText = 'ç­‰å¾…ä¸Šä¼ ';
        dynamicBtn.disabled = true;

        // æ›´æ–°æ»‘æ¡æ˜¾ç¤º
        function updateRange() {
            minNoteVal.innerText = minNoteSlider.value;
            maxNoteVal.innerText = maxNoteSlider.value;
            thresholdVal.innerText = parseFloat(thresholdSlider.value).toFixed(3);
        }

        minNoteSlider.addEventListener('input', updateRange);
        maxNoteSlider.addEventListener('input', updateRange);
        thresholdSlider.addEventListener('input', updateRange);
        updateRange();

        // éŸ³é¢‘ä¸Šä¸‹æ–‡å’Œæ•°æ®
        let audioContext = null;
        let audioBuffer = null;
        let audioFileName = 'audio';
        let currentNotes = [];

        // æ–‡ä»¶ä¸Šä¼ 
        function handleFiles(files) {
            if (!files || !files[0]) return;
            const file = files[0];
            audioFileName = file.name.replace(/\.[^/.]+$/, '');
            fileNameDiv.innerText = `å·²é€‰æ‹©: ${file.name}`;
            const reader = new FileReader();
            reader.onload = (e) => {
                if (!audioContext) audioContext = new (window.AudioContext || window.webkitAudioContext)();
                audioContext.decodeAudioData(e.target.result, (buffer) => {
                    audioBuffer = buffer;
                    setProgress(5, 'è½½å…¥æ–‡ä»¶æˆåŠŸ!');
                    dynamicBtn.disabled = false; // æ¢å¤æŒ‰é’®
                    dynamicBtn.innerText = 'å¼€å§‹è½¬æ¢';
                    downloadBtn.disabled = true; // ç¦ç”¨ä¸‹è½½æŒ‰é’®(é˜²å•¥æ‰ä¹±ç‚¹)
                    infoDiv.innerHTML = 'âœ” éŸ³é¢‘åŠ è½½æˆåŠŸ';
                }, (err) => {
                    infoDiv.innerHTML = 'âŒ è§£ç å¤±è´¥: ' + err;
                    dynamicBtn.innerText = 'æ–‡ä»¶è§£ç å¤±è´¥';
                    setProgress(0, 'ä»€ä¹ˆé¬¼?');
                });
            };
            reader.readAsArrayBuffer(file);
        }

        dropZone.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (e) => handleFiles(e.target.files));
        dropZone.addEventListener('dragover', (e) => e.preventDefault());
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            handleFiles(e.dataTransfer.files);
        });

        // è¿›åº¦æ¡
        function setProgress(percent, text) {
            progressFill.style.width = percent + '%';
            progressText.innerText = text;
        }

        // MIDIç”Ÿæˆå‡½æ•°(ä¸æ•¢æ”¹ï¼Œæ”¹äº†å¿…å‡ºBUG)
        function writeVLQ(value) {
            let buffer = [];
            let v = value;
            buffer.unshift(v & 0x7F);
            v >>= 7;
            while (v > 0) {
                buffer.unshift((v & 0x7F) | 0x80);
                v >>= 7;
            }
            return buffer;
        }

        // é‡å MIDIç”Ÿæˆå‡½æ•°
        function overlapCreateMidiBlob(notes, duration) {
            if (!notes || notes.length === 0) {
                notes = [{midi: 60, start: 0, end: 1, velocity: 100}];
            }

            const ticksPerQuarter = 480;
            const tempo = 500000; // 120 BPM
            const ticksPerSecond = ticksPerQuarter * 2; // 960

            // è½¨é“0ï¼štempo + meta
            let track0 = [];
            track0.push(0x00, 0xFF, 0x51, 0x03,
                (tempo >> 16) & 0xFF,
                (tempo >> 8) & 0xFF,
                tempo & 0xFF);
            track0.push(0x00, 0xFF, 0x03, 5, 65, 117, 100, 105, 111); // "Audio"
            track0.push(0x00, 0xFF, 0x2F, 0x00);

            // è½¨é“1ï¼šå¶æ•°ç´¢å¼•å¸§çš„éŸ³ç¬¦ï¼ˆæ­£å¸¸æ—¶é—´ï¼‰
            let track1_even = [];
            // è½¨é“2ï¼šå¥‡æ•°ç´¢å¼•å¸§çš„éŸ³ç¬¦ï¼ˆå»¶è¿ŸåŠå¸§ï¼‰
            let track1_odd = [];

            // æŒ‰å¼€å§‹æ—¶é—´æ’åº
            const sortedNotes = [...notes].sort((a, b) => a.start - b.start);

            // æŒ‰å¼€å§‹æ—¶é—´åˆ†ç»„ï¼ˆåŒä¸€æ—¶é—´å¼€å§‹çš„éŸ³ç¬¦ï¼‰
            const groups = [];
            let currentGroup = [];
            let currentStart = sortedNotes[0]?.start;

            for (const note of sortedNotes) {
                if (Math.abs(note.start - currentStart) < 0.0001) {
                    currentGroup.push(note);
                } else {
                    groups.push(currentGroup);
                    currentGroup = [note];
                    currentStart = note.start;
                }
            }
            if (currentGroup.length > 0) groups.push(currentGroup);

            // ä¸¤ä¸ªè½¨é“çš„ç‹¬ç«‹æ—¶é—´çº¿
            let lastTick_even = 0;
            let lastTick_odd = 0;

            for (let idx = 0; idx < groups.length; idx++) {
                const group = groups[idx];

                // è®¡ç®—è¯¥ç»„éŸ³ç¬¦çš„åŸå§‹å¼€å§‹æ—¶é—´
                const originalStart = group[0].start;
                const startTick = Math.floor(originalStart * ticksPerSecond);

                // æ ¹æ®ç´¢å¼•å¥‡å¶é€‰æ‹©è½¨é“
                const isEven = idx % 2 === 0;

                // è®¡ç®—è¯¥ç»„éŸ³ç¬¦çš„åŸå§‹ç»“æŸæ—¶é—´ï¼ˆå–æœ€æ™šçš„ï¼‰
                const maxEnd = Math.max(...group.map(n => n.end));
                const endTick = Math.floor(maxEnd * ticksPerSecond);
                const originalDur = endTick - startTick;

                // æ‰€æœ‰éŸ³ç¬¦å»¶é•¿ä¸€å€
                const durTicks = originalDur * 2; // 2å€é•¿åº¦

                if (isEven) {
                    // å¶æ•°è½¨é“ï¼šæ­£å¸¸æ—¶é—´
                    const delta = startTick - lastTick_even;
                    track1_even.push(...writeVLQ(delta >= 0 ? delta : 0));

                    // Note On
                    for (let i = 0; i < group.length; i++) {
                        if (i > 0) track1_even.push(0x00);
                        track1_even.push(0x90, group[i].midi, group[i].velocity);
                    }

                    if (durTicks > 0) {
                        track1_even.push(...writeVLQ(durTicks));
                        for (let i = 0; i < group.length; i++) {
                            if (i > 0) track1_even.push(0x00);
                            track1_even.push(0x80, group[i].midi, 64);
                        }
                        lastTick_even = startTick + durTicks;
                    }
                } else {
                    // å¥‡æ•°è½¨é“ï¼šéœ€è¦è®¡ç®—å½“å‰å¸§çš„å®é™…é•¿åº¦ï¼Œç„¶åå»¶è¿ŸåŠå¸§

                    // è®¡ç®—å½“å‰å¸§çš„é•¿åº¦ï¼ˆåˆ°ä¸‹ä¸€å¸§å¼€å§‹çš„æ—¶é—´ï¼‰
                    let frameLength = 480; // é»˜è®¤å€¼
                    if (idx < groups.length - 1) {
                        const nextStart = groups[idx + 1][0].start;
                        frameLength = Math.floor((nextStart - originalStart) * ticksPerSecond);
                    } else {
                        // æœ€åä¸€å¸§ï¼Œç”¨éŸ³ç¬¦é•¿åº¦ä½œä¸ºå‚è€ƒ
                        frameLength = originalDur;
                    }
                    frameLength = Math.max(1, frameLength);

                    // åŠå¸§å»¶è¿Ÿ
                    const halfFrameTicks = Math.floor(frameLength / 2);
                    const delayedStartTick = startTick + halfFrameTicks;

                    const delta = delayedStartTick - lastTick_odd;
                    track1_odd.push(...writeVLQ(delta >= 0 ? delta : 0));

                    // Note On
                    for (let i = 0; i < group.length; i++) {
                        if (i > 0) track1_odd.push(0x00);
                        track1_odd.push(0x90, group[i].midi, group[i].velocity);
                    }

                    // å¥‡æ•°è½¨é“çš„éŸ³ç¬¦åŒæ ·å»¶é•¿ä¸€å€
                    if (durTicks > 0) {
                        track1_odd.push(...writeVLQ(durTicks));
                        for (let i = 0; i < group.length; i++) {
                            if (i > 0) track1_odd.push(0x00);
                            track1_odd.push(0x80, group[i].midi, 64);
                        }
                        lastTick_odd = delayedStartTick + durTicks;
                    }
                }
            }

            // è½¨é“ç»“æŸ
            track1_even.push(0x00, 0xFF, 0x2F, 0x00);
            track1_odd.push(0x00, 0xFF, 0x2F, 0x00);

            function makeTrackChunk(data) {
                const len = data.length;
                return [
                    0x4D, 0x54, 0x72, 0x6B,
                    (len >> 24) & 0xFF,
                    (len >> 16) & 0xFF,
                    (len >> 8) & 0xFF,
                    len & 0xFF,
                    ...data
                ];
            }

            const track0Chunk = makeTrackChunk(track0);
            const track1_even_chunk = makeTrackChunk(track1_even);
            const track1_odd_chunk = makeTrackChunk(track1_odd);

            // å¤´éƒ¨ï¼š3ä¸ªè½¨é“
            const header = [
                0x4D, 0x54, 0x68, 0x64,
                0x00, 0x00, 0x00, 0x06,
                0x00, 0x01,             // æ ¼å¼1
                0x00, 0x03,             // 3ä¸ªè½¨é“
                (ticksPerQuarter >> 8) & 0xFF,
                ticksPerQuarter & 0xFF
            ];

            const midiBytes = [...header, ...track0Chunk, ...track1_even_chunk, ...track1_odd_chunk];
            return new Blob([new Uint8Array(midiBytes)], {type: 'audio/midi'});
        }

        // é€Ÿåˆ‡MIDIç”Ÿæˆå‡½æ•°
        function speedcreateMidiBlob(notes, duration) {
            if (!notes || notes.length === 0) {
                notes = [{midi: 60, start: 0, end: 1, velocity: 100}];
            }

            const ticksPerQuarter = 480;
            const tempo = 500000; // 120 BPM
            const ticksPerSecond = ticksPerQuarter * 2; // 960

            // è½¨é“0ï¼štempo + meta
            let track0 = [];
            track0.push(0x00, 0xFF, 0x51, 0x03,
                (tempo >> 16) & 0xFF,
                (tempo >> 8) & 0xFF,
                tempo & 0xFF);
            track0.push(0x00, 0xFF, 0x03, 5, 65, 117, 100, 105, 111); // "Audio"
            track0.push(0x00, 0xFF, 0x2F, 0x00);

            // è½¨é“1ï¼šéŸ³ç¬¦
            let track1 = [];
            let lastTick = 0;

            // æŒ‰å¼€å§‹æ—¶é—´åˆ†ç»„
            const groups = new Map();
            notes.forEach(n => {
                const key = n.start.toFixed(6);
                if (!groups.has(key)) groups.set(key, []);
                groups.get(key).push(n);
            });

            // æŒ‰æ—¶é—´æ’åº
            const sortedGroups = Array.from(groups.entries()).sort((a, b) => parseFloat(a[0]) - parseFloat(b[0]));

            for (const [timeStr, group] of sortedGroups) {
                const startTick = Math.floor(parseFloat(timeStr) * ticksPerSecond);
                track1.push(...writeVLQ(startTick - lastTick));
                lastTick = startTick;

                // è¿ç»­Note On (delta 0)
                for (let i = 0; i < group.length; i++) {
                    if (i > 0) track1.push(0x00);
                    track1.push(0x90, group[i].midi, group[i].velocity);
                }

                const maxEnd = Math.max(...group.map(n => n.end));
                const endTick = Math.floor(maxEnd * ticksPerSecond);
                const durTicks = endTick - startTick;
                if (durTicks > 0) {
                    track1.push(...writeVLQ(durTicks));
                    for (let i = 0; i < group.length; i++) {
                        if (i > 0) track1.push(0x00);
                        track1.push(0x80, group[i].midi, 64);
                    }
                    lastTick = endTick;
                }
            }

            track1.push(0x00, 0xFF, 0x2F, 0x00);

            function makeTrackChunk(data) {
                const len = data.length;
                return [
                    0x4D, 0x54, 0x72, 0x6B,
                    (len >> 24) & 0xFF,
                    (len >> 16) & 0xFF,
                    (len >> 8) & 0xFF,
                    len & 0xFF,
                    ...data
                ];
            }

            const track0Chunk = makeTrackChunk(track0);
            const track1Chunk = makeTrackChunk(track1);

            const header = [
                0x4D, 0x54, 0x68, 0x64,
                0x00, 0x00, 0x00, 0x06,
                0x00, 0x01,             // æ ¼å¼1
                0x00, 0x02,             // 2ä¸ªè½¨é“
                (ticksPerQuarter >> 8) & 0xFF,
                ticksPerQuarter & 0xFF
            ];

            const midiBytes = [...header, ...track0Chunk, ...track1Chunk];
            return new Blob([new Uint8Array(midiBytes)], {type: 'audio/midi'});
        }

        // å¿½ç•¥åŒ…ç»œéŸ³é‡MIDIç”Ÿæˆå‡½æ•°
        function traditionalCreateMidiBlob(notes, duration) {
            if (!notes || notes.length === 0) {
                notes = [{midi: 60, start: 0, end: 1, velocity: 100}];
            }

            // ç¬¬ä¸€æ­¥ï¼šæŒ‰éŸ³é«˜åˆå¹¶ç›¸é‚»å¸§ï¼Œå¹¶è®¡ç®—å¹³å‡åŠ›åº¦
            const pitchGroups = new Map();
            notes.forEach(n => {
                if (!pitchGroups.has(n.midi)) pitchGroups.set(n.midi, []);
                pitchGroups.get(n.midi).push({
                    start: n.start,
                    end: n.end,
                    velocity: n.velocity || 100
                });
            });

            const mergedNotes = [];
            const GAP_TOLERANCE = 0.01; // å…è®¸ 0.01 ç§’çš„é—´éš”ï¼ˆå¯è°ƒæ•´ï¼‰

            for (const [midi, events] of pitchGroups.entries()) {
                events.sort((a, b) => a.start - b.start);
                let i = 0;
                while (i < events.length) {
                    let j = i;
                    // åˆå¹¶æ¡ä»¶ï¼šåä¸€ä¸ªçš„å¼€å§‹ å‡å» å‰ä¸€ä¸ªçš„ç»“æŸ å°äºå®¹å¿å€¼
                    while (j + 1 < events.length &&
                    events[j + 1].start - events[j].end <= GAP_TOLERANCE) {
                        j++;
                    }
                    // è®¡ç®—è¿™ä¸€ç»„å¸§çš„å¹³å‡åŠ›åº¦
                    let sumVel = 0;
                    for (let k = i; k <= j; k++) {
                        sumVel += events[k].velocity;
                    }
                    const avgVel = Math.round(sumVel / (j - i + 1));
                    const velocity = Math.min(127, Math.max(1, avgVel)); // é™åˆ¶æœ‰æ•ˆèŒƒå›´

                    mergedNotes.push({
                        midi: midi,
                        start: events[i].start,
                        end: events[j].end,
                        velocity: velocity
                    });
                    i = j + 1;
                }
            }

            if (mergedNotes.length === 0) {
                mergedNotes.push({midi: 60, start: 0, end: 1, velocity: 100});
            }

            // ç¬¬äºŒæ­¥ï¼šç”Ÿæˆäº‹ä»¶åˆ—è¡¨
            const events = [];
            mergedNotes.forEach(n => {
                events.push({time: n.start, type: 'on', midi: n.midi, vel: n.velocity});
                events.push({time: n.end, type: 'off', midi: n.midi, vel: 64}); // Note Off åŠ›åº¦å›ºå®šä¸º 64
            });
            events.sort((a, b) => a.time - b.time);

            // MIDI å‚æ•°
            const ticksPerQuarter = 480;
            const tempo = 500000; // 120 BPM
            const ticksPerSecond = ticksPerQuarter * 2; // 960

            function writeVLQ(value) {
                let buffer = [];
                let v = value;
                buffer.unshift(v & 0x7F);
                v >>= 7;
                while (v > 0) {
                    buffer.unshift((v & 0x7F) | 0x80);
                    v >>= 7;
                }
                return buffer;
            }

            // è½¨é“0ï¼šé€Ÿåº¦ä¸å…ƒæ•°æ®
            let track0 = [];
            track0.push(0x00, 0xFF, 0x51, 0x03,
                (tempo >> 16) & 0xFF,
                (tempo >> 8) & 0xFF,
                tempo & 0xFF);
            track0.push(0x00, 0xFF, 0x03, 8, 78, 111, 118, 111, 108, 117, 109, 101); // "traditional"
            track0.push(0x00, 0xFF, 0x2F, 0x00);

            // è½¨é“1ï¼šéŸ³ç¬¦äº‹ä»¶
            let track1 = [];
            let lastTick = 0;
            for (const ev of events) {
                const tick = Math.floor(ev.time * ticksPerSecond);
                const delta = tick - lastTick;
                if (delta < 0) continue; // å®‰å…¨é˜²æŠ¤
                track1.push(...writeVLQ(delta));
                track1.push(ev.type === 'on' ? 0x90 : 0x80, ev.midi, ev.vel);
                lastTick = tick;
            }
            track1.push(0x00, 0xFF, 0x2F, 0x00);

            function makeTrackChunk(data) {
                const len = data.length;
                return [
                    0x4D, 0x54, 0x72, 0x6B,
                    (len >> 24) & 0xFF,
                    (len >> 16) & 0xFF,
                    (len >> 8) & 0xFF,
                    len & 0xFF,
                    ...data
                ];
            }

            const track0Chunk = makeTrackChunk(track0);
            const track1Chunk = makeTrackChunk(track1);

            const header = [
                0x4D, 0x54, 0x68, 0x64,
                0x00, 0x00, 0x00, 0x06,
                0x00, 0x01,
                0x00, 0x02,
                (ticksPerQuarter >> 8) & 0xFF,
                ticksPerQuarter & 0xFF
            ];

            const midiBytes = [...header, ...track0Chunk, ...track1Chunk];
            return new Blob([new Uint8Array(midiBytes)], {type: 'audio/midi'});
        }

        //FFTå¤„ç†é€»è¾‘(æ”¹ä¸äº†ä¸€ç‚¹)
        function fft(re, im) {
            dynamicBtn.disabled = true; // æš‚æ—¶ç¦ç”¨è½¬æ¢æŒ‰é’®
            dynamicBtn.innerText = 'è½¬æ¢ä¸­...';
            const n = re.length;
            if (n <= 1) return;
            let bits = Math.log2(n);
            for (let i = 0; i < n; i++) {
                let rev = 0;
                for (let j = 0; j < bits; j++) {
                    if ((i >> j) & 1) rev |= 1 << (bits - 1 - j);
                }
                if (rev > i) {
                    [re[i], re[rev]] = [re[rev], re[i]];
                    [im[i], im[rev]] = [im[rev], im[i]];
                }
            }
            for (let len = 2; len <= n; len <<= 1) {
                const half = len / 2;
                const angleStep = -2 * Math.PI / len;
                for (let i = 0; i < n; i += len) {
                    for (let j = 0; j < half; j++) {
                        const angle = angleStep * j;
                        const wRe = Math.cos(angle);
                        const wIm = Math.sin(angle);
                        const uRe = re[i + j];
                        const uIm = im[i + j];
                        const vRe = re[i + j + half] * wRe - im[i + j + half] * wIm;
                        const vIm = re[i + j + half] * wIm + im[i + j + half] * wRe;
                        re[i + j] = uRe + vRe;
                        im[i + j] = uIm + vIm;
                        re[i + j + half] = uRe - vRe;
                        im[i + j + half] = uIm - vIm;
                    }
                }
            }
        }

        //è½¬æ¢é€»è¾‘
        function analyzeDynamic() {
            dynamicBtn.disabled = true;
            dynamicBtn.innerText = 'è½¬æ¢ä¸­...';
            setProgress(30, 'è®¡ç®—FFT...');
            if (!audioBuffer) {
                infoDiv.innerHTML = 'è¯·å…ˆä¸Šä¼ éŸ³é¢‘';
                return;
            }
            setTimeout(() => {
                if (!audioBuffer) {
                    infoDiv.innerHTML = 'è¯·å…ˆä¸Šä¼ éŸ³é¢‘';
                    dynamicBtn.disabled = false;
                    dynamicBtn.innerText = 'å¼€å§‹è½¬æ¢';
                    return;
                }
                const buffer = audioBuffer;
                const sampleRate = buffer.sampleRate;
                const channelData = buffer.getChannelData(0);
                const duration = buffer.duration;
                const minMidi = parseInt(minNoteSlider.value);
                const maxMidi = parseInt(maxNoteSlider.value);
                const threshold = parseFloat(thresholdSlider.value);
                const fftSize = parseInt(fftSizeSelect.value);
                const overlapFactor = parseInt(fftOverlap.value);
                const hopSize = Math.floor(fftSize / overlapFactor);// é‡å ç‡å¯æ§
                const removeEmpty = removeEmptyCheckbox.checked;

                const numFrames = Math.floor((channelData.length - fftSize) / hopSize) + 1;
                const numBins = fftSize / 2 + 1;

                statFrames.innerText = numFrames;
                statBins.innerText = numBins;

                const window = new Float64Array(fftSize);
                for (let i = 0; i < fftSize; i++) {
                    window[i] = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / (fftSize - 1));
                }

                // å…ˆæ”¶é›†æ¯å¸§çš„éŸ³ç¬¦ï¼ˆåŸå§‹æ—¶é—´ï¼‰
                const rawFrames = [];

                for (let frame = 0; frame < numFrames; frame++) {
                    const startSample = frame * hopSize;
                    const re = new Float64Array(fftSize);
                    const im = new Float64Array(fftSize);
                    for (let i = 0; i < fftSize; i++) {
                        if (startSample + i < channelData.length) re[i] = channelData[startSample + i] * window[i];
                    }
                    fft(re, im);

                    const mags = [];
                    let maxMag = 0;
                    for (let i = 0; i < numBins; i++) {
                        const mag = Math.sqrt(re[i] * re[i] + im[i] * im[i]) / fftSize;
                        mags.push(mag);
                        if (mag > maxMag) maxMag = mag;
                    }

                    const frameNotes = [];

                    // æ£€æµ‹å³°å€¼ï¼ˆè¶…è¿‡é˜ˆå€¼ä¸”ä¸ºå±€éƒ¨æœ€å¤§ï¼‰
                    for (let i = 1; i < numBins - 1; i++) {
                        if (mags[i] > threshold && mags[i] > mags[i - 1] && mags[i] > mags[i + 1]) {
                            const freq = i * sampleRate / fftSize;
                            if (freq < 20 || freq > 20000) continue;
                            let midi = Math.round(12 * Math.log2(freq / 440) + 69);
                            if (midi < minMidi || midi > maxMidi) continue;
                            const scale = parseFloat(loudnessScale.value);
                            let rawVel = Math.floor((mags[i] / maxMag) * 100 * scale + 20);
                            const vel = Math.min(127, Math.max(20, rawVel));
                            frameNotes.push({midi, vel}); // æš‚æ—¶ä¸å­˜æ—¶é—´ï¼Œåé¢é‡æ–°è®¡ç®—
                        }
                    }

                    rawFrames.push(frameNotes);

                    if (frame % 20 === 0) {
                        setProgress(10 + Math.floor((frame / numFrames) * 70), `åˆ†æå¸§ ${frame}/${numFrames} (${frameNotes.length} éŸ³)`);
                    }
                }

                //å»é™¤ç©ºç™½å¸§å¹¶é‡æ–°è®¡ç®—æ—¶é—´è½´
                let filteredFrames = rawFrames;
                let removedCount = 0;
                if (removeEmpty) {
                    filteredFrames = rawFrames.filter(frame => frame.length > 0);
                    removedCount = rawFrames.length - filteredFrames.length;
                }

                // é‡æ–°è®¡ç®—æ¯å¸§çš„æ—¶é—´
                const frameDuration = hopSize / sampleRate; // æ¯å¸§çš„æ—¶é•¿ï¼ˆåŸå§‹hopæ—¶é•¿ï¼‰
                const totalDuration = duration; // ç›®æ ‡æ€»æ—¶é•¿
                const newFrameCount = filteredFrames.length;

                // å¦‚æœè¿‡æ»¤åæ²¡æœ‰å¸§ï¼Œåˆ™è¿”å›ç©º
                if (newFrameCount === 0) {
                    dynamicBtn.disabled = false; // æ¢å¤æŒ‰é’®
                    dynamicBtn.innerText = 'å¼€å§‹è½¬æ¢';
                    currentNotes = [];
                    statAvgNotes.innerText = '0';
                    statTotalNotes.innerText = '0';
                    updateNotePreview([]);
                    window.currentNotes = currentNotes;
                    setProgress(100, 'å®Œæˆï¼ˆæ— éŸ³ç¬¦ï¼‰');
                    downloadBtn.disabled = true;
                    infoDiv.innerHTML = 'âš ï¸ æ‰€æœ‰å¸§å‡ä¸ºç©ºç™½ï¼Œè¯·é™ä½é˜ˆå€¼ã€‚';
                    return;
                }

                // æ–°æ—¶é—´è½´ï¼šå°†å‰©ä½™å¸§å‡åŒ€å‹ç¼©åˆ°æ€»æ—¶é•¿å†…ï¼Œæ¯å¸§æ—¶é•¿ä¸º totalDuration / newFrameCount
                const newFrameLength = totalDuration / newFrameCount;

                const allNotes = [];
                for (let i = 0; i < filteredFrames.length; i++) {
                    const start = i * newFrameLength;
                    const end = (i + 1) * newFrameLength;
                    const notes = filteredFrames[i];
                    notes.forEach(n => {
                        allNotes.push({
                            midi: n.midi,
                            start: start,
                            end: end,
                            velocity: n.vel
                        });
                    });
                }

                currentNotes = allNotes;
                const avg = (allNotes.length / newFrameCount).toFixed(1);
                statAvgNotes.innerText = avg;
                statTotalNotes.innerText = allNotes.length;
                statFrames.innerText = `${numFrames}`; // æ˜¾ç¤ºåŸå§‹å¸§æ•°å’Œå»é™¤æ•°
                setProgress(100, 'å®Œæˆï¼');
                window.currentNotes = currentNotes;
                downloadBtn.disabled = false;
                infoDiv.innerHTML = `âœ… è½¬æ¢å®Œæˆï¼Œå…± ${allNotes.length} ä¸ªéŸ³ç¬¦ï¼Œå¹³å‡æ¯å¸§ ${avg} ä¸ªï¼Œå·²å»é™¤ ${removedCount} ç©ºç™½å¸§ã€‚`;
                dynamicBtn.disabled = false; // æ¢å¤æŒ‰é’®
                dynamicBtn.innerText = 'å¼€å§‹è½¬æ¢';
            }, 50); // å»¶è¿Ÿ 50ms è¶³å¤Ÿ UI æ›´æ–°
        }

        function updateNotePreview(notes) {
            dynamicBtn.disabled = false; // æ¢å¤æŒ‰é’®
            dynamicBtn.innerText = 'å¼€å§‹è½¬æ¢';
            const preview = notes.slice(0, 50).map(n => {
                const name = midiToNoteName(n.midi);
                return `<span class="note-tag" title="å¼€å§‹:${n.start.toFixed(2)}s åŠ›åº¦:${n.velocity}">${name} (${n.velocity})</span>`;
            }).join('');
            noteListDiv.innerHTML = preview || 'æ— éŸ³ç¬¦';
        }

        function midiToNoteName(midi) {
            const names = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            return names[midi % 12] + (Math.floor(midi / 12) - 1);
        }

        dynamicBtn.addEventListener('click', analyzeDynamic);

        downloadBtn.addEventListener('click', () => {
            setProgress(100, 'ä¿å­˜MIDIæ–‡ä»¶...');
            if (currentNotes.length === 0) {
                infoDiv.innerHTML = 'æ²¡æœ‰éŸ³ç¬¦æ•°æ®';
                return;
            }
            let blob;
            if (midiModeSelect.value === 'overlap') {
                blob = overlapCreateMidiBlob(currentNotes, audioBuffer ? audioBuffer.duration : 2);
            } else if (midiModeSelect.value === 'traditional') {
                blob = traditionalCreateMidiBlob(currentNotes, audioBuffer ? audioBuffer.duration : 2);
            } else {
                blob = speedcreateMidiBlob(currentNotes, audioBuffer ? audioBuffer.duration : 2);
            }
            currentMidiBlob = blob;
            const modeSuffix = midiModeSelect.value === 'overlap' ? '-OVE' : (midiModeSelect.value === 'traditional' ? '-TRA' : '');
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = audioFileName + '-FFT' + modeSuffix + '.mid';
            a.click();
            URL.revokeObjectURL(url);
        });

// MIDI æ–‡ä»¶é¢„è§ˆæ’­æ”¾å™¨----------------------------------------------------------------
        let previewAudioCtx = null;
        let previewIsPlaying = false;
        let previewStartTime = 0;
        let previewPauseTime = 0;
        let previewProgressInterval = null;
        let previewScheduledNotes = [];
        let previewIsDragging = false;
        let previewActiveTimeouts = [];
        let previewTotalDuration = 0;

// é¢„è§ˆæ’­æ”¾å™¨DOMå…ƒç´ 
        const previewPlayBtn = document.getElementById('previewPlayBtn');
        const previewStopBtn = document.getElementById('previewStopBtn');
        const previewProgress = document.getElementById('previewProgress');
        const previewCurrentTime = document.getElementById('previewCurrentTime');
        const previewTotalTime = document.getElementById('previewTotalTime');

// é¢„è§ˆæ§ä»¶é•¿æœŸæ˜¾ç¤º
        document.getElementById('previewPlayer').style.display = 'block';

        function formatTime(sec) {
            const m = Math.floor(sec / 60);
            const s = Math.floor(sec % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function clearPreviewTimeouts() {
            previewActiveTimeouts.forEach(t => clearTimeout(t));
            previewActiveTimeouts = [];
        }

        async function stopPreview() {
            if (previewProgressInterval) clearInterval(previewProgressInterval);
            clearPreviewTimeouts();
            if (previewAudioCtx) {
                await previewAudioCtx.close();
                previewAudioCtx = null;
            }
            previewIsPlaying = false;
            previewPlayBtn.innerText = 'â–¶ï¸ é¢„è§ˆMIDI';
            previewPlayBtn.style.backgroundColor = '#5fb85f';
            previewProgress.value = 0;
            previewCurrentTime.innerText = '0:00';
            previewTotalTime.innerText = '0:00';
        }

        function updatePreviewProgress() {
            if (!previewIsPlaying || !previewAudioCtx || previewIsDragging) return;
            const elapsed = previewAudioCtx.currentTime - previewStartTime;
            previewCurrentTime.innerText = formatTime(elapsed);
            previewProgress.value = elapsed * 1000;
        }

// MIDI è§£æå™¨
        function parseMidiFile(arrayBuffer) {
            const u8 = new Uint8Array(arrayBuffer);
            const allNotes = []; // å­˜å‚¨æ‰€æœ‰è½¨é“çš„éŸ³ç¬¦
            let ticksPerQuarterNote = 480;
            let tempo = 500000; // 120 BPM

            // è§£ææ–‡ä»¶å¤´
            if (u8.length >= 14 && u8[0] === 0x4D && u8[1] === 0x54 && u8[2] === 0x68 && u8[3] === 0x64) {
                ticksPerQuarterNote = (u8[12] << 8) | u8[13];
            }

            let firstNoteTick = -1;
            let maxTick = 0;

            // é€å­—èŠ‚æ‰«ææ‰€æœ‰éŸ³è½¨
            for (let i = 14; i < u8.length - 8; i++) {
                // æŸ¥æ‰¾ MTrk
                if (u8[i] === 0x4D && u8[i + 1] === 0x54 && u8[i + 2] === 0x72 && u8[i + 3] === 0x6B) {
                    const trackLen = (u8[i + 4] << 24) | (u8[i + 5] << 16) | (u8[i + 6] << 8) | u8[i + 7];
                    const trackEnd = i + 8 + trackLen;
                    let pos = i + 8;

                    // å½“å‰è½¨é“çš„å¾…å¤„ç†éŸ³ç¬¦
                    const pendingNotes = {};
                    let currentTick = 0;

                    // è§£æéŸ³è½¨å†…äº‹ä»¶
                    while (pos < trackEnd) {
                        // è¯»å– delta time
                        let delta = 0;
                        if (pos < trackEnd) {
                            delta = u8[pos++];
                            if (delta & 0x80) {
                                delta = delta & 0x7F;
                                if (pos < trackEnd) {
                                    delta = (delta << 7) | (u8[pos++] & 0x7F);
                                }
                            }
                        }
                        currentTick += delta;

                        if (pos >= trackEnd) break;

                        const status = u8[pos++];

                        // Tempo äº‹ä»¶
                        if (status === 0xFF && pos < trackEnd && u8[pos] === 0x51) {
                            pos++;
                            if (pos < trackEnd) {
                                const len = u8[pos++];
                                if (len === 3 && pos + 2 < trackEnd) {
                                    tempo = (u8[pos] << 16) | (u8[pos + 1] << 8) | u8[pos + 2];
                                    pos += 3;
                                }
                            }
                            continue;
                        }

                        // Note On
                        if (status >= 0x90 && status <= 0x9F && pos + 1 < trackEnd) {
                            const note = u8[pos++];
                            const velocity = u8[pos++];
                            const channel = status & 0x0F;
                            const key = `${channel}_${note}`;

                            if (velocity > 0) {
                                pendingNotes[key] = {tick: currentTick, note, velocity};
                                if (firstNoteTick === -1 || currentTick < firstNoteTick) {
                                    firstNoteTick = currentTick;
                                }
                            } else {
                                if (pendingNotes[key]) {
                                    const start = pendingNotes[key];
                                    allNotes.push({
                                        noteNumber: start.note,
                                        startTick: start.tick,
                                        endTick: currentTick,
                                        velocity: start.velocity
                                    });
                                    if (currentTick > maxTick) maxTick = currentTick;
                                    delete pendingNotes[key];
                                }
                            }
                            continue;
                        }

                        // Note Off
                        if (status >= 0x80 && status <= 0x8F && pos + 1 < trackEnd) {
                            const note = u8[pos++];
                            const velocity = u8[pos++];
                            const channel = status & 0x0F;
                            const key = `${channel}_${note}`;

                            if (pendingNotes[key]) {
                                const start = pendingNotes[key];
                                allNotes.push({
                                    noteNumber: note,
                                    startTick: start.tick,
                                    endTick: currentTick,
                                    velocity: start.velocity
                                });
                                if (currentTick > maxTick) maxTick = currentTick;
                                delete pendingNotes[key];
                            }
                            continue;
                        }
                    }

                    // å¤„ç†å½“å‰è½¨é“æœªå…³é—­çš„éŸ³ç¬¦
                    for (const key in pendingNotes) {
                        const start = pendingNotes[key];
                        allNotes.push({
                            noteNumber: start.note,
                            startTick: start.tick,
                            endTick: maxTick + ticksPerQuarterNote,
                            velocity: start.velocity
                        });
                    }

                    i = trackEnd - 1;
                }
            }

            if (allNotes.length === 0) return {notes: [], duration: 0};

            // å»é™¤å¼€å¤´é™éŸ³
            //if (firstNoteTick > 0) {
            //    allNotes.forEach(n => {
            //        n.startTick -= firstNoteTick;
            //        n.endTick -= firstNoteTick;
            //    });
            //    maxTick -= firstNoteTick;
            //}

            // è®¡ç®—æ—¶é—´
            const secondsPerTick = (tempo / 1000000) / ticksPerQuarterNote;
            const totalSeconds = maxTick * secondsPerTick;

            // è½¬æ¢ä¸ºæ’­æ”¾å™¨æ ¼å¼å¹¶æŒ‰æ—¶é—´æ’åº
            const playNotes = allNotes.map(n => ({
                time: n.startTick * secondsPerTick,
                duration: (n.endTick - n.startTick) * secondsPerTick,
                noteNumber: n.noteNumber,
                velocity: (n.velocity || 100) / 127
            })).sort((a, b) => a.time - b.time);

            return {notes: playNotes, duration: totalSeconds};
        }

// ç”Ÿæˆå¹¶æ’­æ”¾ MIDI æ–‡ä»¶
        async function playCurrentMidi() {
            if (!currentNotes) {
                alert('æ²¡æœ‰éŸ³ç¬¦æ•°æ®ï¼Œè¯·å…ˆè½¬æ¢');
                return;
            }
            let vblob;
            if (midiModeSelect.value === 'overlap') {
                vblob = overlapCreateMidiBlob(currentNotes, audioBuffer ? audioBuffer.duration : 2);
            } else if (midiModeSelect.value === 'traditional') {
                vblob = traditionalCreateMidiBlob(currentNotes, audioBuffer ? audioBuffer.duration : 2);
            } else {
                vblob = speedcreateMidiBlob(currentNotes, audioBuffer ? audioBuffer.duration : 2);
            }
            currentMidiBlob = vblob;

            // æ’­æ”¾ MIDI æ–‡ä»¶
            await playMidiBlob(currentMidiBlob);
        }

        async function playMidiBlob(blob) {
            try {
                // åœæ­¢å½“å‰æ‰€æœ‰æ’­æ”¾
                clearPreviewTimeouts();

                const arrayBuffer = await blob.arrayBuffer();
                const {notes, duration} = parseMidiFile(arrayBuffer);

                if (notes.length === 0) {
                    alert('MIDI æ–‡ä»¶ä¸­æ²¡æœ‰å¯æ’­æ”¾çš„éŸ³ç¬¦');
                    return;
                }

                previewTotalDuration = duration;
                previewScheduledNotes = notes;

                previewPlayBtn.innerText = 'â¹ï¸ åœæ­¢';
                previewPlayBtn.style.backgroundColor = '#ff4444';
                previewIsPlaying = true;

                if (!previewAudioCtx) previewAudioCtx = new (window.AudioContext || window.webkitAudioContext)();
                if (previewAudioCtx.state === 'suspended') await previewAudioCtx.resume();

                previewTotalTime.innerText = formatTime(duration);
                previewProgress.max = duration * 1000;
                previewProgress.value = 0;

                previewStartTime = previewAudioCtx.currentTime;
                previewPauseTime = 0;

                // è°ƒåº¦æ‰€æœ‰éŸ³ç¬¦
                scheduleNotesFromTime(0);

                previewProgressInterval = setInterval(updatePreviewProgress, 50);

            } catch (err) {
                console.error('è§£æ MIDI å¤±è´¥:', err);
                alert('é¢„è§ˆå¤±è´¥ï¼šæ— æ³•è§£æç”Ÿæˆçš„ MIDI æ–‡ä»¶');
            }
        }

        function scheduleNotesFromTime(startTime) {
            clearPreviewTimeouts();
            previewScheduledNotes.forEach(note => {
                if (note.time >= startTime) {
                    const delay = note.time - startTime;
                    const timeout = setTimeout(() => {
                        if (!previewIsPlaying || !previewAudioCtx) return;
                        try {
                            const gainNode = previewAudioCtx.createGain();
                            const osc = previewAudioCtx.createOscillator();

                            osc.type = 'sine';
                            osc.frequency.value = 440 * Math.pow(2, (note.noteNumber - 69) / 12);
                            gainNode.gain.value = note.velocity * 0.15;

                            osc.connect(gainNode);
                            gainNode.connect(previewAudioCtx.destination);

                            const startTime = previewAudioCtx.currentTime;
                            osc.start(startTime);
                            osc.stop(startTime + note.duration);
                        } catch (e) {
                            console.warn('é¢„è§ˆéŸ³ç¬¦æ’­æ”¾å¤±è´¥:', e);
                        }
                    }, delay * 1000);
                    previewActiveTimeouts.push(timeout);
                }
            });
        }

// è¿›åº¦æ¡æ‹–åŠ¨
        previewProgress.addEventListener('mousedown', () => {
            previewIsDragging = true;
        });

        previewProgress.addEventListener('mousemove', (e) => {
            if (!previewIsDragging || !previewTotalDuration) return;

            const rect = previewProgress.getBoundingClientRect();
            let percent = (e.clientX - rect.left) / rect.width;

            // é™åˆ¶ç™¾åˆ†æ¯”åœ¨ 0-1 ä¹‹é—´
            percent = Math.max(0, Math.min(1, percent));

            const newTime = percent * previewTotalDuration;
            previewCurrentTime.innerText = formatTime(newTime);
            previewProgress.value = newTime * 1000;
        });

        previewProgress.addEventListener('mouseup', async (e) => {
            if (!previewIsDragging || !previewAudioCtx || !previewScheduledNotes.length) return;

            const rect = previewProgress.getBoundingClientRect();
            let percent = (e.clientX - rect.left) / rect.width;

            // é™åˆ¶ç™¾åˆ†æ¯”åœ¨ 0-1 ä¹‹é—´
            percent = Math.max(0, Math.min(1, percent));

            const newTime = percent * previewTotalDuration;

            clearPreviewTimeouts();
            previewCurrentTime.innerText = formatTime(newTime);
            previewProgress.value = newTime * 1000;

            if (previewIsPlaying) {
                scheduleNotesFromTime(newTime);
                previewStartTime = previewAudioCtx.currentTime - newTime;
                previewPauseTime = newTime;
            } else {
                previewPauseTime = newTime;
            }

            previewIsDragging = false;
        });

        previewProgress.addEventListener('touchstart', () => {
            previewIsDragging = true;
        });

        previewProgress.addEventListener('touchmove', (e) => {
            if (!previewIsDragging || !previewTotalDuration) return;
            e.preventDefault();

            const touch = e.touches[0];
            const rect = previewProgress.getBoundingClientRect();
            let percent = (touch.clientX - rect.left) / rect.width;

            // é™åˆ¶ç™¾åˆ†æ¯”åœ¨ 0-1 ä¹‹é—´
            percent = Math.max(0, Math.min(1, percent));

            const newTime = percent * previewTotalDuration;
            previewCurrentTime.innerText = formatTime(newTime);
            previewProgress.value = newTime * 1000;
        });

        previewProgress.addEventListener('touchend', async (e) => {
            if (!previewIsDragging || !previewAudioCtx || !previewScheduledNotes.length) return;

            const touch = e.changedTouches[0];
            const rect = previewProgress.getBoundingClientRect();
            let percent = (touch.clientX - rect.left) / rect.width;

            // é™åˆ¶ç™¾åˆ†æ¯”åœ¨ 0-1 ä¹‹é—´
            percent = Math.max(0, Math.min(1, percent));

            const newTime = percent * previewTotalDuration;

            clearPreviewTimeouts();
            previewCurrentTime.innerText = formatTime(newTime);
            previewProgress.value = newTime * 1000;

            if (previewIsPlaying) {
                scheduleNotesFromTime(newTime);
                previewStartTime = previewAudioCtx.currentTime - newTime;
                previewPauseTime = newTime;
            } else {
                previewPauseTime = newTime;
            }

            previewIsDragging = false;
        });

// è¿›åº¦æ›´æ–°å‡½æ•° - æ£€æµ‹æ’­æ”¾ç»“æŸ
        function updatePreviewProgress() {
            if (!previewIsPlaying || !previewAudioCtx || previewIsDragging) return;

            const elapsed = previewAudioCtx.currentTime - previewStartTime;

            // æ£€æŸ¥æ˜¯å¦æ’­æ”¾å®Œæ¯•
            if (elapsed >= previewTotalDuration) {
                // æ’­æ”¾ç»“æŸï¼Œè‡ªåŠ¨åœæ­¢
                stopPreview();
                return;
            }

            previewCurrentTime.innerText = formatTime(elapsed);
            previewProgress.value = elapsed * 1000;
        }

        previewPlayBtn.addEventListener('click', async () => {
            if (previewIsPlaying) {
                // æš‚åœ
                if (previewAudioCtx) {
                    await previewAudioCtx.suspend();
                    previewIsPlaying = false;
                    previewPlayBtn.innerText = 'â–¶ï¸ æ’­æ”¾';
                    previewPlayBtn.style.backgroundColor = '#5fb85f';
                    previewPauseTime = previewAudioCtx.currentTime - previewStartTime;
                    clearInterval(previewProgressInterval);
                }
            } else {
                if (!previewAudioCtx || !previewScheduledNotes.length) {
                    // é¦–æ¬¡æ’­æ”¾ç”Ÿæˆå¹¶æ’­æ”¾ MIDI æ–‡ä»¶
                    await playCurrentMidi();
                } else {
                    // æ¢å¤æ’­æ”¾
                    const now = performance.now() / 1000; // å½“å‰æ—¶é—´ï¼ˆç§’ï¼‰
                    const audioTime = previewAudioCtx.currentTime; // AudioContext æ—¶é—´

                    // è®¡ç®—å®é™…åº”è¯¥æ’­æ”¾çš„ä½ç½®
                    const expectedTime = previewPauseTime; // æš‚åœæ—¶çš„ä½ç½®

                    // å¦‚æœæš‚åœæ—¶é—´è¾ƒçŸ­ï¼Œç›´æ¥æ¢å¤
                    if (now - (previewPauseTime + previewStartTime) < 0.1) {
                        await previewAudioCtx.resume();
                        previewIsPlaying = true;
                        previewPlayBtn.innerText = 'â¹ï¸ åœæ­¢';
                        previewPlayBtn.style.backgroundColor = '#ff4444';

                        previewStartTime = audioTime - previewPauseTime;
                        scheduleNotesFromTime(previewPauseTime);
                        previewProgressInterval = setInterval(updatePreviewProgress, 50);
                        return;
                    }

                    // å¦‚æœæš‚åœæ—¶é—´è¾ƒé•¿ï¼Œé‡æ–°è°ƒåº¦ä»æš‚åœä½ç½®å¼€å§‹çš„éŸ³ç¬¦
                    await previewAudioCtx.resume();
                    previewIsPlaying = true;
                    previewPlayBtn.innerText = 'â¹ï¸ åœæ­¢';
                    previewPlayBtn.style.backgroundColor = '#ff4444';

                    // é‡æ–°è®¡ç®—å¼€å§‹æ—¶é—´
                    previewStartTime = audioTime - previewPauseTime;

                    // æ¸…é™¤æ—§çš„å®šæ—¶å™¨
                    clearPreviewTimeouts();

                    // é‡æ–°è°ƒåº¦ä»æš‚åœä½ç½®å¼€å§‹çš„éŸ³ç¬¦
                    const currentAudioTime = previewAudioCtx.currentTime;
                    previewScheduledNotes.forEach(note => {
                        if (note.time >= previewPauseTime) {
                            const delay = note.time - previewPauseTime;
                            const timeout = setTimeout(() => {
                                if (!previewIsPlaying || !previewAudioCtx) return;
                                try {
                                    const gainNode = previewAudioCtx.createGain();
                                    const osc = previewAudioCtx.createOscillator();

                                    osc.type = 'sine';
                                    osc.frequency.value = 440 * Math.pow(2, (note.noteNumber - 69) / 12);
                                    gainNode.gain.value = note.velocity * 0.15;

                                    osc.connect(gainNode);
                                    gainNode.connect(previewAudioCtx.destination);

                                    const startTime = previewAudioCtx.currentTime;
                                    osc.start(startTime);
                                    osc.stop(startTime + note.duration);
                                } catch (e) {
                                    console.warn('é¢„è§ˆéŸ³ç¬¦æ’­æ”¾å¤±è´¥:', e);
                                }
                            }, delay * 1000);
                            previewActiveTimeouts.push(timeout);
                        }
                    });

                    previewProgressInterval = setInterval(updatePreviewProgress, 50);
                }
            }
        });

        previewStopBtn.addEventListener('click', stopPreview);
    })();
</script>
</body>
</html>